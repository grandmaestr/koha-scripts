#!/bin/bash

set -ex

# include helper functions
if [ -f "/usr/share/koha/bin/koha-functions.sh" ]; then
    . "/usr/share/koha/bin/koha-functions.sh"
else
    echo "Error: /usr/share/koha/bin/koha-functions.sh not present." >&2
    exit 1
fi

# Make sure the files we create are not accessible by anyone else.
umask 0077

usage() {
    local scriptname=$(basename "$0")

    cat <<EOF
$scriptname

This script dumps your Koha instance data for backup or migration.

The schema only option can be used to compare your existing database schema
to the expected Koha structure.

Usage:
$scriptname [--quiet|-q] [--exclude-indexes] [--without-db-name] [-i instance1 [instance2...]] [-s s3://bucket-name]
$scriptname -h|--help

    --schema-only         Dump only the database schema
    --exclude-indexes     Include Zebra indexes on the backup
    --without-db-name     Do not include database name
    -i                    One or more Koha instance names to dump (separated by spaces)
    -s                    URL of the S3 bucket to copy the backups
    --quiet|-q            Make the script avoid printing to STDOUT
                          (useful for calling from another script)
    --help|-h             Display this help message
EOF
}

dump_instance() {
    local name="$1"

    kohaconfig="/etc/koha/sites/$name/koha-conf.xml"
    date=$(date +"%m-%d-%Y-%Hh%M")

    [ "$quiet" = "no" ] && echo "Dumping Koha site $name:"

    # Dump database.
    mysqlhost="$(sudo xmlstarlet sel -t -v 'yazgfs/config/hostname' "$kohaconfig" )"
    mysqldb="$( sudo xmlstarlet sel -t -v 'yazgfs/config/database' "$kohaconfig" )"
    mysqluser="$( sudo xmlstarlet sel -t -v 'yazgfs/config/user' "$kohaconfig" )"
    mysqlpass="$(sudo  xmlstarlet sel -t -v 'yazgfs/config/pass' "$kohaconfig" )"
    backupdir=/tmp
    [ -z "$backupdir" ] && backupdir="/var/spool/koha/$name"
    dbdump="$backupdir/$name-$date.sql.gz"
    dbflag="--databases"
    [ "$without_db_name" = "yes" ] && dbflag=""
    if [ "$schema_only" = "yes" ]; then
        schemadump="$backupdir/$name-schema-$date.sql"
        [ "$quiet" = "no" ] && echo "* schema to $schemadump"
        mysqldump $dbflag --no-tablespaces -d --host="$mysqlhost" --single-transaction \
            --user="$mysqluser" --password="$mysqlpass" "$mysqldb" | sed --expression='s/ AUTO_INCREMENT=[0-9]\+//' > "$schemadump"
    
    else
        [ "$quiet" = "no" ] && echo "* DB to $dbdump"
        mysqldump $dbflag --no-tablespaces --host="$mysqlhost" --single-transaction --user="$mysqluser" --password="$mysqlpass" "$mysqldb" | gzip > "$dbdump"
        
    instancefile="$name.conf"

    # Dump configs, logs, etc.
    metadump="$backupdir/$name-$date.tar.gz"
    [ "$quiet" = "no" ] && echo "* configs, logs to $metadump"

    if [ "$exclude_indexes" = "yes" ]; then
        excludes="--exclude=var/lib/koha/$name/biblios \
                  --exclude=var/lib/koha/$name/authorities"
    fi

   sudo tar -czf "$metadump" -C / $excludes \
        "etc/koha/sites/$name" \
        "etc/apache2/sites-available/$instancefile" \
        "etc/apache2/sites-enabled/$instancefile" \
        "var/lib/koha/$name" \
        "var/log/koha/$name"

    # Make the dump files readable and writeable by the current user.
    sudo chown $(whoami):$(whoami) "$dbdump" "$metadump"

    if [ -n "$s3_url" ]; then
        [ "$quiet" = "no" ] && echo "* copying backups to S3 bucket: $s3_url"
        aws s3 cp "$dbdump" "$s3_url/$name/$name-$date.sql.gz"
        aws s3 cp "$metadump" "$s3_url/$name/$name-$date.tar.gz"
    fi

    [ "$quiet" = "no" ] && echo "Done."
fi
}
# Default values
quiet="no"
exclude_indexes="no"
without_db_name="no"
schema_only="no"
instances=()
s3_url=""

while [ $# -gt 0 ]; do
case "$1" in
--schema-only)
schema_only="yes"
shift ;;
--exclude-indexes)
exclude_indexes="yes"
shift ;;
--without-db-name)
without_db_name="yes"
shift ;;
-i)
shift
while [ $# -gt 0 ] && ! [[ "$1" =~ ^- ]]; do
instances+=("$1")
shift
done ;;
-s)
shift
s3_url="$1"
shift ;;
-h|--help)
usage ; exit 0 ;;
-q|--quiet)
quiet="yes"
shift ;;
-*)
echo "Error: invalid option switch ($1)" >&2; usage; exit 1 ;;
*)
# We expect the remaining stuff are the instance names
break ;;
esac
done

# Read instance names

if [ "${#instances[@]}" -gt 0 ]; then
# We have at least one instance name
for name in "${instances[@]}"; do
if is_instance "$name"; then
dump_instance "$name"
else
if [ "$quiet" = "no" ]; then
echo "Error: Invalid instance name $name" >&2
fi
exit 1
fi
done
else
if [ "$quiet" = "no" ]; then
echo "Error: you must provide at least one instance name" >&2
fi
usage; exit 1
fi

exit 0

